# v0.3.0 Proposal: Observability & Reliability Refactor

**Status:** DRAFT
**Author:** Claude (via dogfooding analysis)
**Date:** 2026-01-02
**Triggered By:** v0.2.17 work order failure with no diagnostic info

---

## Executive Summary

AgentGate can dogfood itself, but when things fail, we don't know why. The v0.2.17 test generation work order created all files correctly but failed with just "Build failed" - no stdout, no stderr, no tool calls, no way to debug.

This proposal outlines a comprehensive refactor to make AgentGate **observable, reliable, and truly production-ready** for dogfooding and external use.

---

## Problem Statement

### Immediate Issue: v0.2.17 WO Failure

```
Run: ac31daa7-620a-451e-86e0-4269fe15b824
Result: failed_build
Error: "Build failed"
```

The agent created 1,824 lines of test code across 3 files. Git shows the changes were made. But we have:
- ❌ No stdout from agent
- ❌ No stderr from agent
- ❌ No tool call history
- ❌ No iteration data file
- ❌ No verification report
- ❌ No way to know what failed

### Root Cause: Information Loss

```typescript
// AgentResult contains rich data:
interface AgentResult {
  stdout: string;           // DISCARDED
  stderr: string;           // Only partial use
  toolCalls: ToolCallRecord[]; // DISCARDED
  tokensUsed: TokenUsage;   // DISCARDED
  durationMs: number;       // DISCARDED
  structuredOutput: any;    // DISCARDED
}

// But we only save:
{ sessionId: string; success: boolean; error?: string }
```

---

## Architectural Issues Identified

### Critical (Must Fix)

| # | Issue | Location | Impact |
|---|-------|----------|--------|
| 1 | **AgentResult not persisted** | `orchestrator.ts:435-442` | No way to debug agent failures |
| 2 | **VerificationReport not persisted** | `orchestrator.ts:459-471` | No way to see what verification found |
| 3 | **IterationData incomplete** | `run-store.ts:96-106` | Missing sessionId, agent metrics, verification ID |
| 4 | **Generic error messages** | Multiple | "Build failed" tells us nothing |

### High (Should Fix)

| # | Issue | Location | Impact |
|---|-------|----------|--------|
| 5 | **No retry logic** | Throughout | Transient failures = terminal |
| 6 | **GitHub failures silent** | `run-executor.ts:421-438` | Run succeeds without PR |
| 7 | **Concurrent limit = error** | `orchestrator.ts:120-124` | Bad UX, no queueing |
| 8 | **Harness config silent failures** | `config-resolver.ts` | Wrong profile used silently |

### Medium (Nice to Have)

| # | Issue | Location | Impact |
|---|-------|----------|--------|
| 9 | **Loop strategy callback explosion** | `run-executor.ts` | 5 callbacks, hard to understand |
| 10 | **Orchestrator imports 15+ modules** | `orchestrator.ts` | Hard to test, tight coupling |
| 11 | **EventBroadcaster leak risk** | `broadcaster.ts` | No auto-cleanup |

---

## Proposed Solution

### Phase 1: Observability Foundation (1-2 days)

**Goal:** Never lose diagnostic information again.

#### 1.1 Persist Full AgentResult

Create `/runs/{runId}/agent-{iteration}.json`:

```typescript
interface PersistedAgentResult {
  iteration: number;
  sessionId: string;
  success: boolean;
  exitCode: number;
  stdout: string;
  stderr: string;
  durationMs: number;
  tokensUsed: TokenUsage | null;
  toolCalls: ToolCallRecord[];
  model: string;
  capturedAt: string; // ISO timestamp
}
```

**Files to modify:**
- `orchestrator.ts` - Call new `saveAgentResult()` after `driver.execute()`
- `run-store.ts` - Add `saveAgentResult()` function
- `run-executor.ts` - Pass agent result through callbacks

#### 1.2 Persist VerificationReport

Create `/runs/{runId}/verification-{iteration}.json`:

```typescript
// Already exists as VerificationReport, just persist it
await saveVerificationReport(runId, iteration, report);
```

**Files to modify:**
- `verifier.ts` or `run-executor.ts` - Save after verification completes
- `run-store.ts` - Add `saveVerificationReport()` function

#### 1.3 Enhance IterationData

```typescript
interface IterationData {
  iteration: number;
  state: RunState;

  // NEW: Agent execution details
  agentSessionId: string | null;
  agentResultFile: string | null;  // Path to agent-{N}.json
  agentDurationMs: number | null;
  agentSuccess: boolean | null;

  // Existing
  snapshotId: string | null;

  // NEW: Verification details
  verificationFile: string | null;  // Path to verification-{N}.json
  verificationPassed: boolean | null;

  feedbackGenerated: boolean;
  startedAt: Date;
  completedAt: Date | null;
  durationMs: number | null;

  // NEW: Error classification
  errorType: 'none' | 'agent_crash' | 'agent_failure' | 'verification_failed' | 'system_error';
  errorMessage: string | null;
}
```

#### 1.4 Structured Error Types

```typescript
enum BuildErrorType {
  AGENT_CRASH = 'agent_crash',           // Agent process died
  AGENT_TASK_FAILURE = 'agent_task_failure',  // Agent reported failure
  TYPECHECK_FAILED = 'typecheck_failed', // Typecheck failed
  TEST_FAILED = 'test_failed',           // Tests failed
  TIMEOUT = 'timeout',                   // Exceeded time limit
  SYSTEM_ERROR = 'system_error',         // Infrastructure issue
}

interface BuildError {
  type: BuildErrorType;
  message: string;
  exitCode: number | null;
  stdout: string;  // Last N lines
  stderr: string;  // Last N lines
  agentResultFile: string;  // Full output here
}
```

---

### Phase 2: Reliability Improvements (2-3 days)

**Goal:** Handle transient failures gracefully.

#### 2.1 Retry Policy

```typescript
interface RetryPolicy {
  maxAttempts: number;
  backoffMs: number;
  backoffMultiplier: number;
  retryableErrors: BuildErrorType[];
}

const DEFAULT_RETRY_POLICY: RetryPolicy = {
  maxAttempts: 2,
  backoffMs: 5000,
  backoffMultiplier: 2,
  retryableErrors: [
    BuildErrorType.TIMEOUT,
    BuildErrorType.SYSTEM_ERROR,
  ],
};
```

#### 2.2 GitHub Operation Modes

```typescript
enum GitHubMode {
  FAIL_FAST = 'fail_fast',      // Fail run if GitHub fails
  BEST_EFFORT = 'best_effort',  // Log warning, continue
  DISABLED = 'disabled',        // No GitHub operations
}
```

#### 2.3 Work Order Queue

Instead of rejecting when at capacity:

```typescript
enum WorkOrderStatus {
  PENDING = 'pending',   // NEW: In queue, waiting
  QUEUED = 'queued',     // Ready to start
  RUNNING = 'running',
  COMPLETED = 'completed',
  FAILED = 'failed',
  CANCELED = 'canceled',
}

interface QueuePosition {
  position: number;
  estimatedStartTime: Date | null;
}
```

---

### Phase 3: Architectural Cleanup (3-5 days)

**Goal:** Simpler, more testable code.

#### 3.1 WorkspaceManager Facade

Instead of 15+ imports in orchestrator:

```typescript
class WorkspaceManager {
  async acquire(source: WorkspaceSource, leaseSeconds: number): Promise<Workspace>;
  async release(workspace: Workspace): Promise<void>;
  async snapshot(workspace: Workspace): Promise<Snapshot>;
  async restore(workspace: Workspace, snapshotId: string): Promise<void>;
  async pushChanges(workspace: Workspace, message: string): Promise<void>;
  async createPR(workspace: Workspace, opts: PROptions): Promise<string>;
}
```

#### 3.2 Simplified Loop Strategy

Replace 5 callbacks with 1:

```typescript
interface LoopStrategy {
  // Called once after each iteration with full context
  onIterationComplete(
    iteration: number,
    agentResult: AgentResult,
    verificationReport: VerificationReport | null,
    context: LoopContext
  ): Promise<LoopDecision>;
}
```

#### 3.3 Event-Driven Architecture

Replace direct calls with event emission:

```typescript
// Orchestrator emits events
orchestrator.emit('iteration:complete', { runId, iteration, result });
orchestrator.emit('verification:complete', { runId, iteration, report });
orchestrator.emit('run:complete', { runId, result });

// Subscribers handle persistence, notifications, etc.
runPersister.on('iteration:complete', saveIterationData);
broadcaster.on('run:complete', notifyClients);
metricsCollector.on('iteration:complete', recordMetrics);
```

---

## Implementation Priority

### Immediate (This Week)
1. **Phase 1.1-1.4** - Observability foundation
2. Run dogfooding again with full diagnostics

### Short Term (Next Week)
3. **Phase 2.1** - Retry policy for transient failures
4. **Phase 2.2** - GitHub operation modes

### Medium Term (2 Weeks)
5. **Phase 2.3** - Work order queue
6. **Phase 3.1** - WorkspaceManager facade
7. **Phase 3.2** - Simplified loop strategy

### Long Term (1 Month)
8. **Phase 3.3** - Event-driven architecture

---

## Success Criteria

After v0.3.0, we should be able to:

1. ✅ **Debug any failure** - Full agent output available for every run
2. ✅ **Retry transient failures** - Network blips don't kill runs
3. ✅ **Queue work orders** - System degrades gracefully under load
4. ✅ **Dogfood reliably** - AgentGate can build itself without mysterious failures
5. ✅ **Onboard new developers** - Cleaner architecture, fewer hidden dependencies

---

## Open Questions

1. **Storage limits?** - Agent stdout can be large. Truncate after N KB?
2. **Retention policy?** - How long to keep agent output files?
3. **Event sourcing?** - Should we go full event-sourced for runs?
4. **Backwards compatibility?** - How to handle existing run data?

---

## Appendix: Files Requiring Changes

### Phase 1 (Observability)
- `packages/server/src/orchestrator/orchestrator.ts`
- `packages/server/src/orchestrator/run-executor.ts`
- `packages/server/src/orchestrator/run-store.ts`
- `packages/server/src/types/run.ts`
- `packages/server/src/verifier/verifier.ts`

### Phase 2 (Reliability)
- `packages/server/src/orchestrator/orchestrator.ts`
- `packages/server/src/control-plane/work-order-service.ts`
- `packages/server/src/types/harness-config.ts`

### Phase 3 (Architecture)
- New: `packages/server/src/workspace/manager.ts`
- `packages/server/src/harness/strategy-registry.ts`
- `packages/server/src/types/loop-strategy.ts`
- `packages/server/src/orchestrator/orchestrator.ts` (major refactor)
